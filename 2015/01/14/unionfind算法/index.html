<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|PT Serif:300,300italic,400,400italic,700,700italic|Lato:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Algorithms," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Union-Find算法　　在一个连通网络中，如果存在链路，使得一个节点能通过这条链路到达另一个节点，那么我们就说这两个节点之间是连通的。在连通性问题中，通常需要判断给定的两个节点是否已经连通，这个过程称为查找(find)操作，此外，若两个点并没有连通，我们可以创建连通这两个节点的链路，从而使得这两个节点处于连通状态，这个过程称为合并(union)操作。在执行合并操作之后，网络处于新的连接状态，这">
<meta property="og:type" content="article">
<meta property="og:title" content="Union-Find算法">
<meta property="og:url" content="http://senlinzhan.github.io/2015/01/14/unionfind算法/index.html">
<meta property="og:site_name" content="Senlin's Blog">
<meta property="og:description" content="Union-Find算法　　在一个连通网络中，如果存在链路，使得一个节点能通过这条链路到达另一个节点，那么我们就说这两个节点之间是连通的。在连通性问题中，通常需要判断给定的两个节点是否已经连通，这个过程称为查找(find)操作，此外，若两个点并没有连通，我们可以创建连通这两个节点的链路，从而使得这两个节点处于连通状态，这个过程称为合并(union)操作。在执行合并操作之后，网络处于新的连接状态，这">
<meta property="og:image" content="http://senlinzhan.github.io/images/data-structure/uf1.png">
<meta property="og:image" content="http://senlinzhan.github.io/images/data-structure/uf2.png">
<meta property="og:image" content="http://senlinzhan.github.io/images/data-structure/uf3.png">
<meta property="og:image" content="http://senlinzhan.github.io/images/data-structure/uf4.png">
<meta property="og:image" content="http://senlinzhan.github.io/images/data-structure/uf6.png">
<meta property="og:image" content="http://senlinzhan.github.io/images/data-structure/uf7.png">
<meta property="og:image" content="http://senlinzhan.github.io/images/data-structure/uf8.png">
<meta property="og:image" content="http://senlinzhan.github.io/images/data-structure/uf9.png">
<meta property="og:image" content="http://senlinzhan.github.io/images/data-structure/uf10.png">
<meta property="og:image" content="http://senlinzhan.github.io/images/data-structure/uf11.png">
<meta property="og:updated_time" content="2017-03-26T15:20:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Union-Find算法">
<meta name="twitter:description" content="Union-Find算法　　在一个连通网络中，如果存在链路，使得一个节点能通过这条链路到达另一个节点，那么我们就说这两个节点之间是连通的。在连通性问题中，通常需要判断给定的两个节点是否已经连通，这个过程称为查找(find)操作，此外，若两个点并没有连通，我们可以创建连通这两个节点的链路，从而使得这两个节点处于连通状态，这个过程称为合并(union)操作。在执行合并操作之后，网络处于新的连接状态，这">
<meta name="twitter:image" content="http://senlinzhan.github.io/images/data-structure/uf1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://senlinzhan.github.io/2015/01/14/unionfind算法/"/>

  <title> Union-Find算法 | Senlin's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Senlin's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Union-Find算法
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-14T22:11:05+08:00" content="2015-01-14">
              2015-01-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法分析/" itemprop="url" rel="index">
                    <span itemprop="name">算法分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2015/01/14/unionfind算法/" class="leancloud_visitors" data-flag-title="Union-Find算法">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Union-Find算法"><a href="#Union-Find算法" class="headerlink" title="Union-Find算法"></a>Union-Find算法</h2><p>　　在一个连通网络中，如果存在链路，使得一个节点能通过这条链路到达另一个节点，那么我们就说这两个节点之间是连通的。在连通性问题中，通常需要判断给定的两个节点是否已经连通，这个过程称为查找<code>(find)</code>操作，此外，若两个点并没有连通，我们可以创建连通这两个节点的链路，从而使得这两个节点处于连通状态，这个过程称为合并<code>(union)</code>操作。在执行合并操作之后，网络处于新的连接状态，这时，我们就可以根据更新后的网络的状态，来判断给定的其它两个节点之间是否连通了。<br>　　为了简化处理，我们可以使用整数来给网络中的节点进行编号。首先，我们给出一个测试程序，程序每次都会要求用户输入一对整数，并且执行以下操作：</p>
<ul>
<li>判断这对整数代表的节点是否处于连通状态，这就是查找操作。</li>
<li>若这两个点没有连通，那么执行合并操作，使得这两个点处于连通状态。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uf.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(<span class="number">10000</span>)</span></span>;                     <span class="comment">// 10000 nodes</span></div><div class="line">    <span class="keyword">int</span> p, q;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (uf.find(p, q)) </div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"connection "</span> &lt;&lt; p &lt;&lt; <span class="string">"-"</span> &lt;&lt; q &lt;&lt; <span class="string">" already exist!"</span> &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            uf.unite(p, q);</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"new connection: "</span> &lt;&lt; p &lt;&lt; <span class="string">"-"</span> &lt;&lt; q &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　　我们可以使用简单的输入来测试程序，输入的两个整数代表两个节点，若这两个节点尚未连通，那么程序就会负责连通这两个点，若这两个点已经连通，则输出提示信息：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">4 5</div><div class="line">new connection: 4-5</div><div class="line">2 4</div><div class="line">new connection: 2-4</div><div class="line">2 5</div><div class="line">connection 2-5 already exist!</div><div class="line">3 1</div><div class="line">new connection: 3-1</div><div class="line">3 4</div><div class="line">new connection: 3-4</div><div class="line">1 2</div><div class="line">connection 1-2 already exist!</div></pre></td></tr></table></figure></p>
<p>　　我们可以用下图<code>1.1</code>来表示对节点执行合并操作的过程，从中可以看到，节点之间的连通是具有传递性，最后，图中的<code>5</code>个节点都处于互通的状态：<br><img src="/images/data-structure/uf1.png" alt=""></p>
<h2 id="Quick-Find算法"><a href="#Quick-Find算法" class="headerlink" title="Quick-Find算法"></a>Quick-Find算法</h2><p>　　在<code>Quick-Find</code>算法中，我们使用数组来表示所有节点的集合，在一开始，数组中的元素的值各不相同，这表示所有的节点均不连通，很显然，要是数组中存在相同的元素值，那么就表示这些元素所代表节点是互通的。由此，判断两个节点是否连通(即查找操作)就变得相当简单，只需要判断数组中的这两项元素的值是否相同，相同就表示它们是连通的。此外，要是这两个节点(假设为<code>A</code>节点和<code>B</code>节点)并不连通，那么就要执行合并操作，这时我们需要遍历整个数组，使得所有与<code>A</code>节点连通的节点都与<code>B</code>节点连通。<br>　　<code>Quick-Find</code>算法中，查找操作的复杂度为<code>O(1)</code>，而合并操作的复杂度为<code>O(N)</code>，<code>N</code>表示数组的长度，即所有节点的数目。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> UnionFind</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFind(<span class="keyword">int</span> n) </div><div class="line">        : num(n), arr(num)</div><div class="line">    &#123;</div><div class="line">	iota(arr.begin(), arr.end(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> arr[p] == arr[q];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!find(p, q))</div><div class="line">	&#123;</div><div class="line">            <span class="keyword">int</span> origin = arr[p];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</div><div class="line">	    &#123;</div><div class="line">                <span class="keyword">if</span> (arr[i] == origin)</div><div class="line">		&#123;</div><div class="line">                    arr[i] = arr[q];</div><div class="line">                &#125;</div><div class="line">            &#125; </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> num;    <span class="comment">// number of nodes</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　图<code>1.2</code>表示了<code>Quick-Find</code>算法合并节点的过程，需要注意，节点中的数字表示节点的编号(即数组元素的下标)，而不是数组元素的值。执行一次合并操作，我们需要遍历所有节点。<br><img src="/images/data-structure/uf2.png" alt=""><br><a id="more"></a> </p>
<h2 id="Quick-Union算法"><a href="#Quick-Union算法" class="headerlink" title="Quick-Union算法"></a>Quick-Union算法</h2><p>　　在<code>Quick-Union</code>算法中，同样使用数组来表示所有节点，数组的下标表示节点的编号。但每个节点可以指向同一连通集中的另一节点，例如，假定<code>arr[1]</code>的值为<code>2</code>，那么就表示编号为<code>1</code>的节点指向编号为<code>2</code>的节点，那么这两个节点就是连通的。<br><img src="/images/data-structure/uf3.png" alt=""><br>　　如果节点指向其它的节点，我们可以顺着这条链路找到链路的最后一个节点，最后的这个节点将指向其自身。根据这个原理，我们可以发现，如果两个节点处于同一个连通集中，那么我们顺着这两个节点指向的链路，最后到达的将是同一个节点，由此可以判断两个节点是否处于同一个连通集中(连通集中的所有节点两两之间直接地或间接地连通)。<br>　　在<code>Quick-Union</code>算法中，判断两个节点是否处于同一个连通集，我们需要遍历两个节点所在的链路，同样，要是两个节点并不在同一个连通集中，则需要执行合并操作，例如，节点<code>1</code>和节点<code>2</code>处于同一连通集，节点<code>3</code>和节点<code>4</code>处于同一连通集：<br><img src="/images/data-structure/uf4.png" alt=""><br>　　为了合并两个节点，使得这两个节点处于同一连通集，我们需要分别顺着这两个节点所在的链路遍历到链路的最后一个节点，并且使其中一个节点指向另外一个节点。例如，假定我们需要合并节点<code>1</code>和节点<code>4</code>，由于节点<code>2</code>和节点<code>3</code>分别是两条链路的最后一个节点，那么我们可以让节点<code>2</code>指向节点<code>3</code>，这样，<code>4</code>个节点就将处于同一个连通集：<br><img src="/images/data-structure/uf6.png" alt=""><br>　　从节点<code>1</code>和节点<code>4</code>分别进行遍历，那么节点<code>3</code>就成为这两条链路共同的最后一个节点。由此可得，只要顺着两个节点所在的链路分别遍历到最后一个节点，再判断链路末端的两个节点是否是同一个节点，我们就可以轻易判断任意两个节点是否处于同一连通集了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> UnionFind</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFind(<span class="keyword">int</span> n) </div><div class="line">        : num(n), arr(num)</div><div class="line">    &#123;</div><div class="line">	iota(arr.begin(), arr.end(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">	<span class="keyword">return</span> find(p) == find(q);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></div><div class="line">    &#123;</div><div class="line">	<span class="keyword">int</span> pRoot = find(p);</div><div class="line">        <span class="keyword">int</span> qRoot = find(q);</div><div class="line">        <span class="keyword">if</span> (pRoot != qRoot)</div><div class="line">	&#123;</div><div class="line">            arr[pRoot] = qRoot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span> (n != arr[n])</div><div class="line">	&#123;</div><div class="line">            n = arr[n];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> num;    <span class="comment">// number of nodes</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　图<code>1.3</code>表示<code>Quick-Union</code>算法合并节点的过程。实际上，链路的最后一个节点可以看成是树的根节点，这个节点将指向其自身，以此，可以将整个连通集看成是一棵树，由于顺着同一连通集中的所有节点向上遍历，那么最后都会到达根节点，据此可判断任意两个节点是否处于同一棵树中(也即同一连通集中)。<br><img src="/images/data-structure/uf7.png" alt=""><br>　　与<code>Quick-Find</code>算法相比，<code>Quick-Union</code>算法的合并操作并不需要遍历整个数组，因此显得相对快一些。为了分析<code>Quick-Union</code>算法的性能，我们需要考虑最坏的情况，在最坏的情况下，<code>Quick-Union</code>算法所形成的树将呈直线形状。例如，假定我们运行前面的测试程序，输入以下内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0 1</div><div class="line">new connection: 0-1</div><div class="line">0 2</div><div class="line">new connection: 0-2</div><div class="line">0 3</div><div class="line">new connection: 0-3</div><div class="line">0 4</div><div class="line">new connection: 0-4</div><div class="line">0 5</div><div class="line">new connection: 0-5</div></pre></td></tr></table></figure></p>
<p>　　那么此时将形成图<code>1.4</code>所示的直线状的树：<br><img src="/images/data-structure/uf8.png" alt=""><br>　　此时，每次若需要查找节点<code>0</code>，我们就需要对直线状的树遍历一次。如果根据这种方式构建出一颗具有<code>N</code>个节点的直线树，那么平均每次需要执行的遍历操作次数为：<br>$$<br>T = \frac{0+1+2+ \cdots + (N-1)}{N} = \frac{N-1}{2}<br>$$<br>　　按照这种方式构造出具有<code>N</code>个节点的直线状的树，那么我们需要输入<code>N</code>对整数，总的遍历操作次数为：<br>$$<br>T_{total} = \frac{N(N-1)}{2}<br>$$</p>
<h2 id="Weighted-Quick-Union算法"><a href="#Weighted-Quick-Union算法" class="headerlink" title="Weighted Quick-Union算法"></a>Weighted Quick-Union算法</h2><p>　　在合并两棵树的过程，我们是使一棵树的根节点指向另一棵树的根节点，这时可以选择将大树连接到小树上，也可以将小树连接到大树上。图<code>1.5</code>表示了这个过程。这时我们可以发现，要是将大树连到小树，那么合并之后的树的高度将会增加<code>1</code>，而要是将小树连接到大树上，那么合并后的树的高度将不变。<br>　　为了防止<code>Quick-Union</code>算法出现最坏情况，在合并两棵树的过程，我们需要尽量阻止树的高度增加。为此，可以为每棵树增加一个计数器，用来存储树的节点数目，在合并两棵树时，就可以通过判断两棵树的节点数目，从而将小树连接到大树上，尽量阻止树高度的增加。这种算法就称为<code>Weighted Quick-Union</code>算法。<br><img src="/images/data-structure/uf9.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> UnionFind</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFind(<span class="keyword">int</span> n) </div><div class="line">        : num(n), size(num), arr(num)</div><div class="line">    &#123;</div><div class="line">	for_each(size.begin(), size.end(), [](<span class="keyword">int</span> &amp;elem) &#123; elem = <span class="number">1</span>; &#125; );</div><div class="line">	iota(arr.begin(), arr.end(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> find(p) == find(q);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> pRoot = find(p);</div><div class="line">        <span class="keyword">int</span> qRoot = find(q);</div><div class="line">        <span class="keyword">if</span> (pRoot != qRoot)</div><div class="line">	&#123;</div><div class="line">            <span class="keyword">if</span> (size[pRoot] &lt; size[qRoot])</div><div class="line">	    &#123;</div><div class="line">                arr[pRoot] = qRoot;</div><div class="line">                size[qRoot] += size[pRoot];</div><div class="line">            &#125;</div><div class="line">	    <span class="keyword">else</span></div><div class="line">	    &#123;</div><div class="line">                arr[qRoot] = pRoot;</div><div class="line">                size[pRoot] += size[qRoot];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">( <span class="keyword">int</span> n )</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>( n != arr[n] )</div><div class="line">	&#123;</div><div class="line">            n = arr[n];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> num;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　使用<code>Weighted Quick-Union</code>算法，在最坏情况下，假定树总共有$2^N$个节点，那么我们从任意叶节点开始，最多需要<code>N</code>次遍历就能到达根节点，实际上判断两个节点是否存在于同一棵树中的操作的其时间复杂度为<code>O(log N)</code>。<br>　　假定存在两棵树<code>A</code>和<code>B</code>，其节点数分别为$N_1$和$N_2$，且$N_1 \leq N_2$，对<code>A</code>和<code>B</code>进行合并，那么在合并之后，通常<code>A</code>的高度将会增加<code>1</code>，而<code>B</code>的高度将保持不变，合并之后的树总节点树为$N_1+N_2$。可以证明，在合并后的树中，从任意叶节点到达根节点，最多需要$\log(N_1+N_2)$次操作，因为$1+\log N_1 = \log(N_1+N_1) \leq \log(N_1+N_2)$。</p>
<h2 id="路径压缩的Weighted-Quick-Union算法"><a href="#路径压缩的Weighted-Quick-Union算法" class="headerlink" title="路径压缩的Weighted Quick-Union算法"></a>路径压缩的Weighted Quick-Union算法</h2><p>　　在<code>Weighted Quick-Union</code>算法所形成的树，只有少量的节点远离根节点，实际上这个算法非常高效，但我们还可以做得更好。在<code>Weighted Quick-Union</code>算法中，从叶节点遍历到根节点，在最坏情况下是<code>O(log N)</code>时间操作，我们可以对此进行改进，使得这个操作接近常量时间。<br>　　当从叶节点开始遍历到根节点的过程中，我们可以改变每两个节点中其中一个节点的指向，使其指向其前面的第二个节点，从而使路径缩短一半。正如图<code>1.6</code>所示，我们对直线形状的树执行折半路径压缩之后，路径缩短了将近一半，从而使树的高度减小，使树变得更扁平。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> n)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>( ; n != arr[n]; n = arr[n] ) </div><div class="line">    &#123;</div><div class="line">        arr[n] = arr[arr[n]];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/images/data-structure/uf10.png" alt=""><br>　　除了折半路径压缩算法之外，还可以使用完全路径压缩算法。假定我们从叶节点遍历到根节点的过程中，能使所有的节点都指向根节点，那么整棵树将变得更加扁平，这种方法称为完全路径压缩。<br>　　图<code>1.7</code>显示了使用这个算法来合并节点的过程，在树中顺着叶节点遍历到根节点的过程中，会使得路径中的所有节点直接与根节点连接，从而使树变得更加扁平。<br><img src="/images/data-structure/uf11.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> n)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> root = n;</div><div class="line">    <span class="keyword">while</span> (root != arr[root])</div><div class="line">    &#123;</div><div class="line">         root = arr[root];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i != arr[i]; i = t) </div><div class="line">    &#123;</div><div class="line">        t = arr[i];</div><div class="line">        arr[i] = root;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　尽管通过路径压缩使得整棵树变得更加扁平，但却需要执行了一下额外的操作，实际上<code>Weighted Quick-Union</code>算法与路径压缩的<code>Weighted Quick-Union</code>算法相比，执行性能非常接近。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882" target="_blank" rel="external">Algorithms in C++ 3rd Edition by Robert Sedgewick</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Algorithms/" rel="tag">#Algorithms</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/10/19/优先队列和堆排序/" rel="next" title="优先队列与堆排序">
                <i class="fa fa-chevron-left"></i> 优先队列与堆排序
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/03/13/多项式乘法与加法/" rel="prev" title="多项式算法的实现">
                多项式算法的实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
          <p class="site-description motion-element" itemprop="description">高性能</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">62</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/senlinzhan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/zongming" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">
    &nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;总访问量: <span id="busuanzi_value_site_pv"></span>
</span>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'http-senlinzhan-github-io';
      var disqus_identifier = '2015/01/14/unionfind算法/';
      var disqus_title = "Union-Find算法";
      var disqus_url = 'http://senlinzhan.github.io/2015/01/14/unionfind算法/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  




  
  

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("3hpOVboxSmUbrCIVNTjmjnfz-gzGzoHsz", "79f6dhW4lQNoYmUHPASfe44T");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
